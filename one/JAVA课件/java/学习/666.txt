//关键字：class

//字面量：整数，小数，字符，字符串，布尔(ture  false)，空
//Null不可以直接打印，需要以字符串的形式打印
//'' 一个字符   “”字符串
//
//变量  数据类型+变量名=数据
//数据改变时，可以用变量存储，数据发生变化，只要修改变量值即可
//int a=10;      System.out.println(a);
//



//'\t'  打印时把字符串长度补齐到8或8的整数，
//System.out,println("name"+'\t'+"age");


//任意数据都是以二进制的形式来存储的
//16进制：a 10      f  15
//二进制  0b开头
//八进制   0开头
//十六进制  0x开头

//十进制转换成其他进制  :不断除以几进制，直到商为0的时候，在将余数倒着读
//不想算用电，脑的计算器，程序员版本

//a  97   A  65
//

//eg"1920x1080是指屏幕上有1920x1080个小方格构成，即xxx个像素
//黑白图：白色1 黑度0
//灰度图：由灰度表
//彩色图：光学三原色：红绿蓝用数字分别表示和区分（0-255范围内）
//                    (,,)三个数字填充、

//声音：波形图所对应的 数据

//java 语言数据类型：基本数据类型和引用数据类型
//                   四类八种（整数，浮点数，字符，布尔）

//标识符   ：就是给  类，方法，变量等起的名字。
//1，由数字，字母，下划线和美元符组成
//2,不能数字开头
//3，不能关键字
//4，区分大小写  calss不行  Class可以

//软性建议
//方法和变量
//一个单词的时候，全部小写
//多个单词，第一个单词首字母小写，其他单词首字母大写

//类名
//全部都首字母大写

//最重要的，见名字知道意思

//键盘录入
//java 帮我们写好一个类叫scanner,这个类可以接收键盘输入的数字
//使用步骤
//1，导包，必须出现在类定义的上面  import java.util.Scanner;
//创建对象，只有Scanner sc=。。。    只有sc是变量名可以改变
  
Scanner sc=new Scanner(System.in);

//接收数据
System.out.println(“请输入数据”);
int i=sc.nextInt();
System.out.println(“请输入第二个数据”);
int j=sc.nextInt();

//运算符和表达式
//小数参与计算时候，结果有可能不精确
//整数参与计算只能得到整数

//隐式转换：自动类型提升，取值范围小的转换成取值范围大的数据
//byte<short<int<long<float<double
//byte,short,char 运算时候会直接提升为int,在进行计算
//int a=10;
//double b=a;

//强制转换
//取值范围大的数值赋值给取值范围小的变量，同样数据过大强制转换会报 错
//

//算术运算符

//   +
//""（字符串）+数据(包括字符，整数，浮点数，布尔)就是拼接,不考虑字符串和顺序的先后顺序
//+操作符从左到右依次执行
//int age=10;
//System.out.println(“age”);  age
//System.out.println(age);  10
//字符相加
//字符加字符或者字符加数字   都会转换成数字在计算
//

//自增运算符
//++ --
//用法和c相同

//赋值运算符
//=
//+=  -=  *=  /=
short a=10;
a+=1;   //a  11   等同于a=(short)(a+1);避免转换导致a的类型改变   

//关系运算符
//==  ！=  >  >=  <  <=
//结果都是boolean类型的数据

//逻辑运算符
//& 逻辑与 都是真才是真
//| 逻辑或  有一个真就是真
//^ 逻辑异或  相同为false ，不同为ture（记忆，结婚相同为false）
//!  去反，注意要么只写一个，要么就不写 

//短路逻辑运算符，有短路效果
//&&和||  短路与，短路或
//目的在于提高运行的效率，左边的表达式能确定最终的结果就不在参与运行看

//三元运算符
//

//快捷键
//crtl+alt+L



//原码，反码，补码
//原码： 符号位（0正1负）+数据（数值）
//一个字节最大为127，最小为-127
//原码对正数进行计算是不会有问题的，负数有问题
//反码：为了解决原码不能计算负数的问题
//正数的反码无需求。反码在原码的基础上，符号位不变，数值取反
//对反码进行+-计算，在取回原码就是负数的运算结果
0000 0000  这两个反码的原码值都是0
1111 1111     跨正负数就会有一个误差
//补码：用来解决上述的问题，错开一位,+1
//-128-127

//隐式转换，前面补充0
//强制转换，去掉前面的数据，若后面的8位开头为0，则直接计算
//若开头为1，则当作补码来运算


//&   左右是数字  都为真就是真
//|               一个1就是1 
//^
//!
//<<        左移，低位补0  正数直接拿原码计算，左移一次乘以2
//>>          右移，高位补0或1                   除以2
//>>>无符号的右移   高位补0

//流程控制语句
//
//顺序结构
//
//分支结构
//布尔类型的变量不需要也不必要==判断，直接写在小括号里面
//if   else if    else
//

//switch
//default的位置和省略
//可以写在任意位置，习惯写在最下面
//case穿透
//语句中没有写break，会导致下一个case也执行直到遇到break
//case 1,2,3,4,5->


//新特性
case 1->{
}
case 2->{
}
//省略了break 的使用

//循环结构
//for和while如果在结构内定义变量，循环结束后就不能再次使用看
//一般的，知道次数用for，只知道结束条件用while

//无限循环

//获取随机数
//import java.util.Random
//Random r=new Random();
//r.nextInt(bound 100);   0-99
//小括号内一定是从0开始到bound-1结束
//想要不从0开始需要在末尾加值
//7-99   int num=r.nextInt(bound 92+1)+7


//数组:可以用来存储同种数据类型的多个值
//需要考虑隐式转换：int  可以包含byte,int short
//double  :byte short int long float double 
//数组初始化
//静态初始化：int[] array=new int[]{11,22,33};
//简写：int[] array={11,2,3};
//数组的名字实际上代表数组的地址值

//数组的访问
//数组名[索引]

//数组动态初始化
int arr=new int[3];
arr[0]=12;
//数组的默认初始化值0，0.0，‘/u0000’(字符类型)，false,null(引用数据类型)

//数组的内存
//arr.length,数组中的长度

//二维数组
int [][]arr=new int[]][]{{11,22}
                         {22,33} 
						 };//建议这样写
Syste.out.println(arr[0]);//打印地址值


//方法是程序中最小的执行单元
//提高代码的复用性和可维持性
//方法的定义
//1，简单的
public static void 方法名(){
//代码
}
调用
方法名();
//2，带参数
public static void 方法名(10,20){

}
//形参和实参
//调用
方法名(int x,int u);


//3，带返回值的,需要用到返回的结果
//public static 返回值类型 方法名(){
return   ;
}

//1，直接调用
   ();//不会产生结果

//2，赋值调用
类型 a=();
//3，输出调用
System.out.println(调用函数);
//当方法没有返回值，return 代表结束语句

/重载：同类中，定义了多个同名方法，且功能相同
//四个注意点
//有不同的参数类型或者参数个数不同，***与返回值是无关的，方法名是相同的，在同一个类当中
//*顺序不同构成重载但意义不大
//public static void age(int a):
public ststic double age(double b,int a):
//是重载了，与void 和double 所决定的返回值无关，后面有关
//
//return 和break
//1,结束方法，返回结果
//执行到了return 整个方法都结束了
//2，结束循环或者switch
//


//拷贝顺序数组,从arr中拷贝,内容为from到to
public static int[] copyarr(int[] arr,int from,int to){
int[] newArr=new int[to-from];//限制了新数组的大小
//伪造索引的思想
int tem=0;
for(int i=from;i<to;i++){
newArr[tem]=arr[i];
tem++;
}
return newArr;
}

//方法的内存原理
//基本的内存原理
1,方法被调用后就会进入栈，栈内存先进后出根据调用先后，而进入栈内存
//
//基本数据类型：存储在自己的空间中，赋值后也是赋予的真实的值
//引用，数据类型{只要有new，在堆当中）,实际存储的是地址值，使用其他空间中的数据
//也因此如果改变地址处的值会对引用的变量造成影响

//传递基本数据类型，传递的是真实的数据，形参改变，不影响实参的值
//比如函数的调用，只有加了return  eg number=change(number);

//而对于引用数据类型，调用方法时相当于同时指向地址，改变地址，实参也会改变



//面向对象
//类：对象共同的特征
//对象：真实存在的具体东西


//类似于结构体和.h文件，不需要static
public class 类名(){
1，成员变量（属性）
String brand;
double price;


2行为（方法）
public void call(){
}
public void playphone(){
}
3,构造器
4，代码块
5，内部类

}

//获得类的对象，在正式写的类中使用
类名 +变量名=new 类名();
//使用，赋值
变量名.  =    ;
变量名.方法名();

//总结从类中获得具体的对象
//javabean类，不带main
//测试类（粗浅理解为主函数），带main
//0  0.0  false  null(引用类型：类，接口，数组，String)   不同的类型默认初始化不同
//函数与结构体的区别在于前者有static,且有具体的赋值





//封装：对象代表什么，就得封装对应的数据，/
//正确的设计对象的属性和方法
private关键字
//是一个权限修饰符
//可以修饰成员
//被private修饰的成员只能在本类中才能被访问
//使用

public class Girl{
private int age;

//赋值
public void setAge(int a){
if()
age=a;
else
System.out.println("非法数据“）;
}

//对外提供数据
public void getAge(){
return age;
}

//空参构造
public Girl(){
//特殊的
this(int,string);
//使用this();仅能够使用一次且在非空构造中使用，且要符合格式

}
//非空参构造
public Girl(int age，String name){
this.name=nane;
this.age=age;

}
}
//对外使用
gir1.setAge(-18);
girl.getAge();

//成员变量和局部变量起冲突时候
//就近原则 ，冲突下一次的使用会用离他最近的变量
//用远距离的：this.ageinsert


//构造器，构造方法：创建对象的时候给成员变量进行赋值
//方法名和类名相同，大小写也要一致
//没有返回值，连void 都没有
//没有具体的返回值（不能由return 待会结果数据）

//创建的对象的由虚拟机调用，不能手动调用构造方法
//每创建一次对象，就会调用一次构造方法
//如果没有自己写任何的构造方法，虚拟机给我们加一个空参构造的方法
//1，调用的空参构造
Girl s=new Girl();
//2，
Girl s=new Girl(18,"XIAOAIAI");

//实际上，无论是否使用，都要手动书写无参构造，和有参构造
//快捷键  alt+insert 
//alt+Fn+insert

//对象内存图
//一个对象的内存图
//两个对象的内存图
//
//两个引用指向同一个对象
Student s1=new Student();
s1.name="aqiang";
Student s2=s1;
s2.name="azhen";
//最终的结果s1,s2的name都被改变变成azhen
s1=NULL；//断掉指向

//基本数据类型：数据值存储在自己的空间中的
//赋值也是赋真实的值
//引用数据类型：          其他的空间中，自己空间存储地址值
//赋值的是地址名

//this作用：区分局部变量和成员变量
// 本质：所在方法调用者（类）的地址值

//成员变量和局部变量（方法内）
//有默认初始值     没有，需要传参
//堆             栈
//new的对象消失就消失       方法结束就消失
//整个类中有效         方法中有效
//



//API  应用程序编程接口
//API帮助文档：帮助更好使用和查询API的一个工具

//字符串的使用
//所有的字符串文字都被视为次类的对象
//字符串不变，他们的值被创建后不能被更改，对字符串的重新赋值，相当于创建了新的类、
//可以进行空参构造

//传递字符数组，根据字符数组的内容再创建一个新的字符串对象
char []cha={'a','v'};
String name=new String(cha);
//修改String，先改变char在进行传递
byte[] bytes={97,98,99,100};
String s5=new String(bytes);//根据字节数组的内容转换为字符

//1，直接赋值,通过=，
//2,通过new String();会浪费内存空间，因为即使内容相同，最终也会在创建一个空间
直接赋值会复用字符串常量池中的
而new出来是不会复用的，而是开辟了一个新的空间



//字符串的比较
//==  基本数据类型就是比较具体的值
//    引用数据类型，比较的是地址值
//new string;  和=  两个的地址不同，一个堆一个在串池（在堆中但是只有直接赋值=才在串池）里面
//比较内容
boolean result=s1.equals(s2);//考虑大小写的内容比较，英文的
               s1.equalsIgnoreCase(s2);

//遍历字符串
//public char charAt(int index);根据 索引返回字符
//public int length();    返回此字符串的长度

//使用
//数组名.length      字符串对象.length()   两个的区别
//字符串对象.charAt(index);    索引的字符
//判断是字符还是数字  char a=='0';    a>='A';
//拼接字符串，直接+
//字符串的反转，倒着遍历

//截取字符串的内容：包头不包尾，包左不包右
//String start=字符串.substring(int ,int);从0开始，尾部加一

//字符数字和整型数字的转换
char gender=s1.charAt(16);
int num=gender-48;//对于字符转换成数字
//将字符串传换为数字，遍历字符串获得每一个字符，在转换为数字，在进行计算


//字符串对象.replace(“”,“”);//旧的值转换成新的值
StringBuilder  可以看成一个容器，创建之后里面的内容是可变的
//提高字符串的操作效率，
//构造方法
1，空参
2，

//常用方法
StringBuilder sb=new StringBuilder(“”);//可以加参和空参
//注意这个比较特殊，打印sb，不是地址值而是属性值
sb.append();//添加元素 ，可以是基本数据类型，字符等等
sb.reverse();  //将容器内容进行反转
int len=sb.length();
String str=sb.toString();//把容器再变回去字符串

//链式编程
int len=substring().replace().reverse().length();
//只要对象类型就可以不断的使用

StringJoiner(间隔符号);
StringJoiner(间隔符号，开始符号，结束符号 );
//无空参构造
 sj.add("");
int length=sj.length();   包括间隔符和内容
String str=sj.toString();


//字符串拼接的底层原理
//1，没有变量参与，都是字符串，直接值+，会复用串池
//2，有          ，以StringBilder来进行，创建新的字符串
//                   优化，以数组，但是还是效率低
//所以用StringBuilder

//若空间不够的话，会自动扩容为34
//若容量超出16*+2=34的容量后则以实际容量为准
//默认容量：16
sb.capacity();获得容量
sb.length(); 长度，内容有多少

//新switch用法
String str=switch(number){
   case '0'->"";
   case '1'


};

//想要修改字符串的内容
1,subString进行截取，拼接到右边去
2，变成字符数组，再进行调整
char[] arr=str.toCharArray();//变成字符数组

String result=new String(arr);//变回字符串





//集合  ：ArrayLIst,自动扩容，自动边长短
//存储基本（不可以直接存储，需要转换成包装类）和引用数据类型

 
//泛型：限定集合中存储数据的类型
ArrayList list<String>=new ArrayList<String>();
//若为空，则打印[]
//不是地址值，而是集合中存储的数据


boolean add(E e);//加
boolean remove(E e);//
E remove(int index);//返回被删的元素
E set(int index,E e);//指定索引下的元素修改
E get(int index);//获取指定索引的元素
int siz();     //集合的长度，元素的个数

boolean result=list.add("aaa");
//正常一定会添加成功
boolean result1=list.remove("");
String str=list.remove(1);
//删除，指定内容和第几个内容，返回不同

String str1=list.set(1,"ddd");
//修改，下标从0开始计数

String str2=list.get(0);
//获取

int a=list.size();

//基本数据类型对应的包装类
//byte    Byte
//short   Short
//char      Character
//int       Integer
//  float       Float
//  double      Double 
// boolean     Boolean
ArrayLIst<Integer> list1=new ArrayList<>();

//还可以定义一个类的集合
public class Student{

}
Student s1=new Student("",);
ArrayList<Student> list2=new ArrayList<>();
list2.add(s1);


//System.exit(0);直接停止虚拟机的运行

//如何在循环和switch  的嵌套中跳出
loop:

break loop;
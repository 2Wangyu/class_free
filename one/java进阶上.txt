//static
//1,在变量中private static   ;
//代表在所有的新创造的对象中这个数据将会共享
//新的赋值方法  类名.对象=赋值的内容;
//优先于对象先出现，和main方法一起出现，堆内存的存储具体的值
//对于所有对象来说是共享的
//2，对于方法
//因为是通用的，可以直接使用一些写好的，不用new了



//静态方法
//工具类：帮我们做一些事情的，
//2，需要私有化构造方法
//1.需要见名字知道意思
//测试类
//javabean类，描述一类事物

//总结，静态方法只能访问静态变量和方法，
//因为无法确定调用那个非静态的方法和变量
//非静态方法可以访问静态变量或静态方法也可以访问非静态的成员变量和成员方法
//静态方法中没有this关键字

//从内存的角度
//静态随类的产生而存在，非静态随对象的产生而存在

//总结，对于在main类中静态变量用private,对于方法中用public
//在静态方法中，只能用private构造器让他不被调用，public static方法写一些直接用的方法不需要new对象 了


//继承
public class Student extends Person{
//          子类（派生类）      父类（基类或超类）
}
//把多个子类中重复的代码抽取到父类中提高复用性
//子类可以增加其他功能，使子类更强大

//父类：1,见名知道意思 2，所有的成员变量需要私有  3，构造方法        4，get/set方法

//使用场景，类和类之间存在相同的内容（条件一），满足子类是父类的一种（条件二）

//继承的特点
//只支持单继承(一个子类继承一个父类，多个父类就错了)
//不支持多继承，但支持多层继承，是指父类继续继承下一个父类
//java写好了，每一个类都直接或者间接的继承与Object（指最终的父类）

//小tips，书写代码的时候从最上面的父类开始写起
//对于上面的类先写完后，从最小的类写，并且开始调用，并且可以直接调用父类中的方法
//小细节，如果父类的一个方法改成private就不可以被子类调用

//开发细节：先验证格式是否正确，再验证是否唯一

//构造方法，子类不继承
//成员变量的private，不可以直接继承值，只能通过get,set
//可以继承类中的方法，是虚方法表（非private,static,final）修饰的


//继承:
//成员变量的访问特点：就近原则，一般优先为局部变量（方法中的变量）,再到本类成员位置再到父类（出现多个变量重名的情况）
//name根据完整的就近原则去判断  this.name:子类中的           super.name:父类中
//成员方法：
//方法调用会有个隐含的this
//super.方法();去到父类
//方法的重写，当父类的方法不能满足子类现在的需求时，子类就需要重写方法
//@Override：代表重写
//eg. @Override
public void eat(){
}

//方法重写的本质
//虚方法表会从上一级到下一级并且会由于方法的重写发生覆盖的现象
//而调用时会从当前级开始如果未被重写则去上一级找。

//私有方法，静态方法不可以，因为都无法被添加到虚方法表
//方法重写时需要与父类保持一致，返回值要小于父类，访问权限大于父类

//小细节，重写方法的时候
public void eat(){
super.eat()；//先调用父类的方法
//再加入特有的
}

//构造方法，父类中的构造方法时不会被子类继承的，父类默认的无参构造先执行，再执行自己的
//否则使用的父类数据没有初始化而无法使用
//所以子类的构造方法第一行语句默认super();不写也存在
//如果要用父类的有参构造，手动书写super(参数,参数,参数);进行调用
public Studeng(){
super();
System.out.  .....

}
public Student(int ,String，double){
super(int ,String);
this.bouns=bouns;//子类特有的：private  的赋值

}
//this 当前方法调用者的地址值
//super,代表父类的存储空间
this()://调用本类的其他构造方法（包含了super();），就不会再添加super();


//多态
//子类的对象可以给父类和子类都可以

//同种类型的对象表现出不同形态
//目的：一个方法可以接受不同的对象，并且调用内部不同的方法
//父类类型 对象名称=子类对象;
FU f=new Zi();

//第一种用法,方法的参数是不同的子类的时候，将参数设为父类的对象
register(s1);//s1代表student类
register(s2);//s2代表了teacher类
public static void register(Person p){

}
//第二种用法
Person p=new Student();
p.setAge(22);
p.show();

//调用条件：
//继承/实现
//父类引用指向子类对象
//有方法的重写

//调用成员的特点
//成员变量:编译运行看左边，
//看左边的父类中有没有这个变量，有则编译成功，否则编译失败
//运行的时候，获取的是左边父类中的值



//成员方法，编译看左边，运行看右边（用子类中的）

//优势：
//1，右边的对象可以实现解耦合，便于扩展和维护。
//根据需求改边new的子类，就可以使用不同类中的方法
//
//2，用父类型作为参数，接受所有子类对象
//StringBuilder    Arraylist

//弊端
//不能调用子类的特有方法（解决，调用者变回子类类型就可以了，强制转化类型）
//不可以瞎强制类型，关键字  a instanceof(Dog),如果a是狗类型就返回true,反之
//新特性
//a instanceof Cat c,判断和强转结合在一起来写
//如果为Cat则强转为Dog类型，转换之后变量名为Dog
//否则返回false
if(a instanceof Dog)
Dog d=(Dog)a;
d.特有方法
//新
// if(a instanceof Dog d){
     d.特有方法
}
//深刻的,错误的是不同的类别，相同的小于的都可以转换
Animal cat=new Cat();
Bird bird=new Bird();
cat instanceof Animal
cat instanceof Cat
bird instanceof Animal


//Person p=new Student();自动类型转换，
//Student s=(Student)p;强制类型转换     
//将子类转换成真正的子类类型，调用子类独有功能

BufferedReader dataIn=new BufferedReader(System.in);
String temp=dataIn.readLine();


import java.util.Arrays;
//创建匿名数组
anArray={,,,,,};//错误的
anArray=new int[]{,,,,,,};
int[] arr=anArray;

//对象数组
Mydate[] mydate=new Mydate[];//
mydate[0]=new Mydate();//初始化
//几种构造数组方法
String a[]=new String[];//错误
String a[]=new String[2];
a[0]={};

//
String a[]=new String[]{"","",""};
String a[]=new String[3]{"","",""};//错误的

//二维数组
int [][]a=new int[x][];//必须且只需长度new出来
a[0]=new int[x];

int[] b[]={ {},
             {}, 
};//奇怪的方法

//访问
a[0][0]=new String("chen");
a[0][1]="chen";
//二维数组
System.out.println(Arrays.deepToString(a));

//输出二维数组
a[0],a,ArraystoString(a)
//输出a[0],输出a,输出a中每个元素的数组的地址
ArraysToString(a[0]);
//输出a[0]中的元素

//数组大小不能改变，只能new掉但会抛弃掉原来的数据
//数组拷贝
System.arraycopy(from,fromindex,to,toIndex,count);
                 from数组 从第几个拷贝，to,从第几个，拷贝几个
int[]  copy=Arrays.copyof(original,orginal.length);
//新建copy为original的拷贝并可以自主构造original的长度

Arrays.fill(a,3);//将a中全部填充为3

Arrays.sort(a);//将数组排序，从小到大
            (a,Collections.reverseOrder);//从大到小
            (a,String.CASE_INSENSITIVE_ORDER);//忽略大小写排序
int a=Arrays.binarySearch(a,r);//是否可以从a中找到r，a大于0找到了
//可以找数或者字符串




//包就是文件夹。
//规则：公司域名反写+包的作用，需要全部英文小写。
//仅仅是同包中，java.lang 不需要
//如果两个包的同名类，则需要全类名
banking.Student s=new banking.Studeng();
 
 
 
 final
//1,最终方法，不能被重写，父子类中子类不可以重写
//2，最终类，不能被继承，不想去修改这个最终类的时候
//3，常量，只能被赋值一次
//常量：一个单词全部大写，多个，全部大写单词之间下划线分隔开
//基本类型，数据值不改变，引用类型，地址值不变，内部属性值可以变化
//没创建一个对象，会被改变，但这个值在这个对象是确定的
//static final 是真正的常量

//应用：不希望被改变
//区别于static ，


//权限修饰符
//1，private,同一个类中
//2，空着不写,只能在本包中使用，可以同包不同类
//3，protected,受保护的，不同包下的子类，指一个子类在另一个包中，可以使用父类的
//4,public:
//一般只用private和public 
//如果方法中的代码是抽取其他方法中共性的代码，一般也私有

//代码块
//局部代码块：方法中的，结束局部变量周期
{
}
//构造代码块：重复的时候需要
1,写在成员位置的代码块
2,把多个构造方法中重复的代码抽取出来
3.执行实际，先执行代码块再执行构造方法
//现在更多的是写成方法来使用了

//以上构造现在都不怎么使用了

//静态代码块：随着类的加载而加载(第一次new)，自动触发，只执行一次，创建多个对象的时候不会重复出现（多次new时候）
//用于初始化去使用
static{

}
//单独写容易被反复调用
//多用于初始化，里面只能用静态的,让它只执行一次。




//抽象类 ：存在一个抽象方法必须写抽象类
public abstract 类名{}
//抽象方法:共性的行为抽取到父类之后，子类执行的内容不同，子类不能具体确定执行内容的
//又为使强制让子类重写方法,直接在父类中写
public abstract void work();//对于父类不需要额外写什么

//抽象类中不能实例化即不能创建对象
//抽象类中不一定有抽象方法，反之一定
//可以有构造方法，可以由方法
//子类，重写所有抽象方法或者子类是抽象类

//抽象的意义在于可以方便于其他人的调用，且只需去看父类的内容


//接口：就是一种规则，对行为的抽象
//public interface 接口名{}         不能实例化
//接口和类之间是实现关系  public class implements 接口名{
  public abstract void swim();
}
//接口的子类(实现类)即继承的子类
//要么重写接口中的所有抽象方法，要么是抽象类
public class 类名 extends 父类名 implements 接口1，接口2{
       分别重写父类的抽象方法
               接口中的方法
}
       
//成员特点
//成员常量：只能是常量，默认修饰符：public static final
//构造方法：没有
//成员方法：抽象方法，public abstract 类名(){}

//类和类是继承的关系，只能单继承，不能有多个爹，但是可以多层继承，指有爷爷（Java还是父类）
//类和接口：实现关系，当出现重名方法的时候，只需要重写一次
//接口和接口：继承，单继承或多继承，,如果继承子接口，重写所有抽象方法（包括父类的和自己的）
//接口 extends 接口


//额外的
//1，有方法体的方法，
//默认方法：public default 返回值类型 方法名();
//不强制重写，但重写的时候去掉default关键字，按照重弄步骤只是去掉default
//多个接口存在同名的默认方法就必须重写

//静态方法,不允许被重写
public static 返回值类型 方法名(){};
//目的在于可以有选择性的调用借口或类中的方法

//私有化，接口中重复的代码，但不想被使用
private (static) 返回值类型 方法名(){}
//有static 为静态方法服务，无static为普通的
// 



//接口的应用，1，去写各种对应接口从而实现类中实现
              2，接口作为参数，可以传其的所有的实现类对象
			接口类型 j=new 实现对象();


//当只想重写接口中的一个方法
public class Inter{

}
//适配器，类 命名:接口名+Adapter
//对接口中的抽象方法进行空实现
//对真正的实现类继承中间类，并重写所需用的方法
public  abstract class InterAdapter implements Inter{
//实现空实现，方法重写了但是其中是空的内容
}
//
public class InterImp1 extends InterAdapter{
//重写所需方法
}

 
//内部类：内部类是外部类的一部分，单独出现没有意义
//内部类直接访问外部类的成员包括私有，外部类访问必须创建对象再通过对象去访问


//成员，静态，局部内部类，匿名内部类需要掌握
//1，属于外部类的成员,可以随便被修饰
//获取对象，1，外部类.内部类 对象名=new 外部类().new 内部类();
            2，在外部类中编写方法，返回其对象new 内部类();
			再调用使用
			Outer o=new Outer();
			Object（所有都可以的） inner=0.方法();
            一般用于private class 内部类(){}
public class Outer{//举例
      private int a=10;
      public class Inner{
	  private int a=20;
	  public void show(){
	  int a=30;
	  //a  30//从局部向内部向外部逐一寻找
	  //this.a 20
	  //Outer.this.a  10
	  }
	  }
}
//2,静态内部类：只能访问外部类中的静态变量和方法，访问非静态得创造对象,在内部类中创建外部类的对象
外部类名.内部类 对象名=new 外部类名.内部类名();
 对于静态的都可以用类名点调用
 Outer.Inner.静态方法名();
 
//3，局部内部类
内部类定义在方法里面，相当于局部变量
外界无法直接使用，需要在方法内部创建对象并使用
直接访问外部类成员和方法内的局部变量
//局部变量不能使用public

4,匿名内部类,外面已经写好了一些了
可以在成员位置和局部位置
 new 类名或接口名(){
 重写方法
 @Override
 public void show(){}
 };
 new的对象是下面重写的内容，而这个new的内容类名或接口是继承或者实现关系
 //使用场景：1，整体作为参数传递，不需要再创建对象了，当只需要用到一次时
            2，Swim s=new Swim(){
			重写方法
			};
             s.方法();
			 3,整体.方法();//直接调用
 
 
 
 
 
 
 